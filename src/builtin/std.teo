/// @name std
/// The Teo standard library
namespace std {

    /// @name EnvVars
    /// The environment variables
    declare struct EnvVars {
        declare static function new(): Self
        declare function subscript(key?: String): String?
    }

    /// @name ENV
    /// The environment variables
    let ENV = EnvVars()

    declare struct Null {
        declare static function new(): Self
    }

    declare struct Bool {
        declare static function new(from?: String): Self
    }

    declare struct Int {
        declare static function new(from?: String | Int64): Self
    }

    declare struct Int64 {
        declare static function new(from?: String | Int): Self
    }

    declare struct Float32 {
        declare static function new(from?: String | Float): Self
    }

    declare struct Float {
        declare static function new(from?: String | Float32): Self
    }

    declare struct Decimal {
        declare static function new(from?: String): Self
    }

    declare struct String {
        declare static function new(from?: Int | Int64 | Float | Float32 | Bool): Self
    }

    #if available(mongo)
    declare struct ObjectId {
        declare static function new(from?: String): Self
    }
    #end

    declare struct Date {
        declare static function new(from?: String): Self
    }

    declare struct DateTime {
        declare static function new(from?: String): Self
    }

    declare struct File { }

    declare struct Regex { }

    declare struct Array<T> {
        declare static function new(): Self
        declare function subscript(index?: Int): T?
    }

    declare struct Dictionary<T> {
        declare static function new(): Self
        declare function subscript(key?: String): T?
    }

    declare struct Range<T> { }

    /// @name Action
    /// Represents the predefined actions
    interface option enum Action {
        create = 1
        update = 1 << 1
        delete = 1 << 2
        copy = 1 << 3
        find = 1 << 4
        first = 1 << 5
        connect = 1 << 6
        disconnect = 1 << 7
        set = 1 << 8
        join = 1 << 9
        count = 1 << 10
        aggregate = 1 << 11
        groupBy = 1 << 12
        codeName = 1 << 13
        upsert = .create | .update
        connectOrCreate = .connect | .create
        joinCreate = .join | .create
        joinDelete = .join | .delete
        findFirst = .find | .first
        entry = 1 << 14
        nested = 1 << 15
        codePosition = 1 << 16
        single = 1 << 17
        many = 1 << 18
        codeAmount = 1 << 19
    }

    /// @name Sort Order
    /// Represents the sort order
    enum Sort {
        asc
        desc
    }

    /// @name String Match Mode
    /// Whether the string query is case sensitive or not
    enum StringMatchMode {
        default
        caseInsensitive
    }

    /// @name Database
    /// Represents the supported database of Teo
    interface enum Database {
        /// @name MongoDB
        /// The MongoDB database    
        mongo
        /// @name MySQL
        /// The MySQL database
        mysql
        /// @name PostgreSQL
        /// The PostgreSQL database
        postgres
        /// @name SQLite
        /// The SQLite database
        sqlite
    }

    /// @name TypeScript HTTP Provider
    /// Specify the API which provides HTTP request functionality.
    interface enum TypeScriptHTTPProvider {
        /// @name Fetch
        /// Use the fetch API. This is the default value
        fetch
        /// @name Taro
        /// Use the Taro's API
        taro
        /// @name WeChat
        /// Use the WeChat's API
        wechat
    }

    /// @name Client Language
    /// The programming langauge of the generated client
    interface enum ClientLanguage {
        /// @name TypeScript
        /// The TypeScript programming language
        typeScript(httpProvider: TypeScriptHTTPProvider?)
        /// @name Swift
        /// The Swift programming language
        swift
        /// @name Kotlin
        /// The Kotlin programming language
        kotlin
        /// @name C#
        /// The C# programming language
        cSharp
        /// @name Dart
        /// The Dart programming language
        dart
    }

    /// @name Runtime
    /// Represents the supported runtime of Teo
    interface enum Runtime {
        /// @name Rust
        /// The rust runtime
        rust
        /// @name Node.js
        /// The Node.js runtime
        node
        /// @name Python
        /// The python runtime
        python
    }

    #if available(mysql)
    interface enum MySQLDatabaseType {
        varChar(len?: Int)
        text
        char(len?: Int)
        tinyText
        mediumText
        longText
        bit(len?: Int)
        tinyInt(len?: Int, signed: Bool)
        int(signed: Bool)
        smallInt(signed: Bool)
        mediumInt(signed: Bool)
        bigInt(signed: Bool)
        year
        float
        double
        decimal(precision?: Int, scale?: Int)
        dateTime(len?: Int)
        date
        time(len?: Int)
        timestamp(len?: Int)
        json
        longBlob
        binary
        varBinary
        tinyBlob
        blob
        mediumBlob
    }
    #end

    #if available(postgres)
    interface enum PostgreSQLDatabaseType {
        text
        char(len?: Int)
        varChar(len?: Int)
        bit(len?: Int)
        varBit
        uuid
        xml
        inet
        boolean
        integer
        smallInt
        int
        bigInt
        oid
        doublePrecision
        real
        decimal(precision?: Int, scale?: Int)
        money
        timestamp(len?: Int)
        timestampTz(len?: Int)
        date
        time
        timeTz
        json
        jsonB
        byteA
    }
    #end

    #if available(sqlite)
    interface enum SQLiteDatabaseType {
        text
        integer
        real
        decimal
        blob
    }
    #end

    #if available(mongo)
    interface enum MongoDBDatabaseType {
        string
        bool
        int
        long
        double
        date
        timestamp
        binData
    }
    #end

    interface enum ResetDatasets {
        auto
        dataSets(names?: DataSet[])
    }

    interface enum Method {
        get
        post
        put
        patch
        delete
    }

    /// @name Delete
    /// Specify what to do if the related record is deleted.
    interface enum Delete {
        /// @name No Action
        /// If related record is deleted, do nothing
        noAction
        /// @name Nullify
        /// If related record is deleted, set the foreign key to null.
        /// This is the default behavior
        nullify
        /// @name Cascade
        /// If related record is deleted, delete this record, too.
        cascade
        /// @name Deny
        /// Deny related record to be deleted
        deny
        /// @name Default
        /// If related record is deleted, set the foreign keys to default values.
        /// If any of the foreign keys doesn't have a default value, an error is raised.
        default
    }

    /// @name Update
    /// Specify what to do if the related record is updated.
    interface enum Update {
        /// @name No Action
        /// If related record is updated, do nothing
        noAction
        /// @name Nullify
        /// If related record is updated, set the foreign key to null.
        nullify
        /// @name Update
        /// If related record is updated, update the foreign key.
        update
        /// @name Delete
        /// If related record is updated, delete this record.
        delete
        /// @name Deny
        /// Deny foreign key value of related record to be updated.
        deny
        /// @name Default
        /// If related record is updated, set the foreign keys to default values.
        /// If any of the foreign keys doesn't have a default value, an error is raised.
        default
    }

    /// @name Client Host
    /// The connection URL to the server for the client
    interface enum ClientHost {
        /// @name string
        /// A constant string value.
        string(value?: String)
        /// @name inject
        /// The value is injected into the generated code.
        inject(value?: String)
    }

    /// @name Connector
    /// Represents the database connection
    declare config connector {
        /// @name Provider
        /// Represents the type of database this app connects
        provider: Database
        /// @name URL
        /// The URL of the database to connect to
        url: String
    }

    /// @name Server
    /// Define the HTTP server configuration
    declare config server {
        /// @name bind
        /// On which IP and port the HTTP server binds
        bind: (String, Int)
        /// @name path prefix
        /// The request URL path prefix
        pathPrefix: String?
    }

    /// @name Entity Generator
    /// Define an entity generator
    declare config entity {
        /// @name Provider
        /// Which runtime is used for the generated entities
        provider: Runtime
        /// @name Destination
        /// Where the generated entity is placed
        dest: String
    }

    /// @name Client Generator
    /// Define a client generator
    declare config client {
        /// @name Provider
        /// Which programming language is used for the generated client
        provider: ClientLanguage
        /// @name Destination
        /// Where the generated client is placed
        dest: String
        /// @name Package
        /// Whether generate code only or a package, defaults to `true`
        package: Bool?
        /// @name Host
        /// The host for the generated client
        host: ClientHost
        /// @name Object Name
        /// The main object name for the generated package
        objectName: String?
        /// @name Git Commit
        /// Whether do `git commit` after each generation
        gitCommit: Bool?
    }

    /// @name Admin Dashboard Generator
    /// Define an admin dashboard generator
    declare config admin {
        /// @name Destination
        /// Where the generated client is placed
        dest: String
        /// @name Host
        /// The host for the generated admin dashboard
        host: ClientHost
        /// @name Languages
        /// The supported languages
        languages: admin.Language[]?
    }

    #if available(database)
    declare config debug {
        logQueries: Bool?
        logMigrations: Bool?
        logSeedRecords: Bool?
    }
    #end

    #if available(database)

    declare builtin synthesized shape Args
    declare builtin synthesized shape FindManyArgs
    declare builtin synthesized shape FindFirstArgs
    declare builtin synthesized shape FindUniqueArgs
    declare builtin synthesized shape CreateArgs
    declare builtin synthesized shape UpdateArgs
    declare builtin synthesized shape UpsertArgs
    declare builtin synthesized shape CopyArgs
    declare builtin synthesized shape DeleteArgs
    declare builtin synthesized shape CreateManyArgs
    declare builtin synthesized shape UpdateManyArgs
    declare builtin synthesized shape CopyManyArgs
    declare builtin synthesized shape DeleteManyArgs
    declare builtin synthesized shape CountArgs
    declare builtin synthesized shape AggregateArgs
    declare builtin synthesized shape GroupByArgs
    declare builtin synthesized shape RelationFilter
    declare builtin synthesized shape ListRelationFilter
    declare builtin synthesized shape WhereInput
    declare builtin synthesized shape WhereUniqueInput
    declare builtin synthesized shape ScalarWhereWithAggregatesInput
    declare builtin synthesized shape CountAggregateInputType
    declare builtin synthesized shape SumAggregateInputType
    declare builtin synthesized shape AvgAggregateInputType
    declare builtin synthesized shape MaxAggregateInputType
    declare builtin synthesized shape MinAggregateInputType
    declare builtin synthesized shape CreateInput
    declare builtin synthesized shape CreateInputWithout
    declare builtin synthesized shape CreateNestedOneInput
    declare builtin synthesized shape CreateNestedOneInputWithout
    declare builtin synthesized shape CreateNestedManyInput
    declare builtin synthesized shape CreateNestedManyInputWithout
    declare builtin synthesized shape UpdateInput
    declare builtin synthesized shape UpdateInputWithout
    declare builtin synthesized shape UpdateNestedOneInput
    declare builtin synthesized shape UpdateNestedOneInputWithout
    declare builtin synthesized shape UpdateNestedManyInput
    declare builtin synthesized shape UpdateNestedManyInputWithout
    declare builtin synthesized shape ConnectOrCreateInput
    declare builtin synthesized shape ConnectOrCreateInputWithout
    declare builtin synthesized shape UpdateWithWhereUniqueInput
    declare builtin synthesized shape UpdateWithWhereUniqueInputWithout
    declare builtin synthesized shape UpsertWithWhereUniqueInput
    declare builtin synthesized shape UpsertWithWhereUniqueInputWithout
    declare builtin synthesized shape UpdateManyWithWhereInput
    declare builtin synthesized shape UpdateManyWithWhereInputWithout
    declare builtin synthesized shape Select
    declare builtin synthesized shape Include
    declare builtin synthesized shape OrderByInput
    declare builtin synthesized shape Result
    declare builtin synthesized shape CountAggregateResult
    declare builtin synthesized shape SumAggregateResult
    declare builtin synthesized shape AvgAggregateResult
    declare builtin synthesized shape MinAggregateResult
    declare builtin synthesized shape MaxAggregateResult
    declare builtin synthesized shape AggregateResult
    declare builtin synthesized shape GroupByResult
    declare builtin synthesized shape ScalarUpdateInput    

    /// @name Map
    /// Specify an underlying database table name for the model
    declare unique model decorator map(tableName?: String)

    /// @name Id
    /// Specify the model's primary index
    declare unique model decorator id(fields?: FieldIndexes<Self>[], map?: String?)

    /// @name Index
    /// Add an index to the model
    declare model decorator index(fields?: FieldIndexes<Self>[], map?: String?)

    /// @name Unique
    /// Add a unique constraint to the model
    declare model decorator unique(fields?: FieldIndexes<Self>[], map?: String?)

    /// @name Migration
    /// Specify the migration operations for the model
    declare unique model decorator migration(renamed: Enumerable<String>?, version: String?, drop: Bool?)

    /// @name Before Save
    /// Specify the action to trigger before an object is saved
    declare unique model decorator beforeSave(pipeline?: Pipeline<Null, Ignored>)

    /// @name After Save
    /// Specify the action to trigger after an object is saved
    declare unique model decorator afterSave(pipeline?: Pipeline<Null, Ignored>)

    /// @name Before Delete
    /// Specify the action to trigger before an object is deleted
    declare unique model decorator beforeDelete(pipeline?: Pipeline<Null, Ignored>)

    /// @name After Delete
    /// Specify the action to trigger after an object is deleted
    declare unique model decorator afterDelete(pipeline?: Pipeline<Null, Ignored>)

    /// @name Can Read
    declare unique model decorator canRead(pipeline?: Pipeline<Null, Ignored>)

    /// @name Can Mutate
    declare unique model decorator canMutate(pipeline?: Pipeline<Null, Ignored>)

    /// @name Action
    /// Specify disabled actions
    declare unique model decorator action {
        variant(enable?: Enumerable<Action>)
        variant(disable: Enumerable<Action>)
    }

    /// @name Generate Client
    /// Specify whether generate client for this model
    declare unique model decorator generateClient(generate?: Bool)

    /// @name Generate Entity
    /// Specify whether generate entity for this model
    declare unique model decorator generateEntity(generate?: Bool)

    /// @name Show in Studio
    /// Specify whether show this model in Teo Studio
    declare unique model decorator showInStudio(show?: Bool)

    /// @name Synthesize Shapes
    /// Whether automatically synthesize shapes for this model
    declare unique model decorator synthesizeShapes(synthesize?: Bool)

    /// @name Map
    /// Specify an underlying database column name for the model field
    declare unique model field decorator map(columnName?: String)

    #if available(mysql)
    /// @name Database Type
    /// Specify an underlying database type for the model field
    declare unique model field decorator db(type?: MySQLDatabaseType)
    #end

    #if available(postgres)
    /// @name Database Type
    /// Specify an underlying database type for the model field
    declare unique model field decorator db(type?: PostgreSQLDatabaseType)
    #end

    #if available(sqlite)
    /// @name Database Type
    /// Specify an underlying database type for the model field
    declare unique model field decorator db(type?: SQLiteDatabaseType)
    #end

    #if available(mongo)
    /// @name Database Type
    /// Specify an underlying database type for the model field
    declare unique model field decorator db(type?: MongoDBDatabaseType)
    #end

    /// @name Readonly
    /// Disallow this field to be written by the client
    declare unique model field decorator readonly

    /// @name Writeonly
    /// Disallow this field to be read by the client
    declare unique model field decorator writeonly

    /// @name Internal
    /// Disallow this field to be read or write by the client
    declare unique model field decorator internal

    /// @name Write on Create
    /// This field can only be written on create
    declare unique model field decorator writeOnCreate

    /// @name Write Once
    /// This field can only be written if current value is null
    declare unique model field decorator writeOnce

    /// @name Write Nonnull
    /// This field can only be written if new value is not null
    declare unique model field decorator writeNonNull

    /// @name Read If
    /// This field can be read by the client if the pipeline passes
    declare unique model field decorator readIf(cond?: Pipeline<Self, Ignored>)

    /// @name Write If
    /// This field can be written by the client if the pipeline passes
    declare unique model field decorator writeIf(cond?: Pipeline<Self, Ignored>)

    /// @name Read Write
    /// This field can be written and read by the client, this is the default behavior
    declare unique model field decorator readwrite

    /// @name Present With
    /// Specify when some other field are not null, this field is required
    declare unique model field decorator presentWith(fields?: Enumerable<ScalarFields<Self>>)

    /// @name Present Without
    /// Specify when some other field are null, this field is required
    declare unique model field decorator presentWithout(fields?: Enumerable<ScalarFields<Self>>)

    /// @name Present If
    /// Specify when some condition passes, this field is required
    declare unique model field decorator presentIf(cond?: Pipeline<Self, Ignored>)

    /// @name Atomic
    /// This field can be updated with atomic updator
    declare unique model field decorator atomic

    /// @name Nonatomic
    /// This field cannot be updated with atomic updator
    declare unique model field decorator nonatomic

    /// @name Id
    /// Specify this field as the model's primary index
    declare exclusive model field decorator id(sort: Sort?, length: Int?, map: String?)

    /// @name Index
    /// Index this field
    declare unique model field decorator index(sort: Sort?, length: Int?, map: String?)

    /// @name Unique
    /// Unique index this field
    declare unique model field decorator unique(sort: Sort?, length: Int?, map: String?)

    /// @name Virtual
    /// Specify a virtual field
    declare unique model field decorator virtual

    /// @name Input Omissible
    /// When type checking and generating clients, the input is always optional
    declare unique model field decorator inputOmissible

    /// @name Output Omissible
    /// When generating clients, the output is always optional
    declare unique model field decorator outputOmissible

    #if available(mongo)

    /// @name Auto
    /// The field value is automatically set by the underlying database
    declare unique model field decorator auto

    #end

    #if available(sql)

    /// @name Auto Increment
    /// The field value is a serial number automatically set by the underlying database
    declare unique model field decorator autoIncrement

    #end

    /// @name Default
    /// Specify a default value for this field
    declare unique model field decorator default(value?: ThisFieldType | Pipeline<Null, ThisFieldType>)

    /// @name Foreign Key
    /// This field is used as foreign key
    declare unique model field decorator foreignKey

    /// @name On Set
    /// This pipeline is triggered when value is set
    declare unique model field decorator onSet(pipeline?: Pipeline<ThisFieldType?, ThisFieldType?>)

    /// @name On Save
    /// This pipeline is triggered before the value is saving into the database
    declare unique model field decorator onSave(pipeline?: Pipeline<ThisFieldType?, ThisFieldType>)

    /// @name On Output
    /// This pipeline is triggered on output
    declare unique model field decorator onOutput(pipeline?: Pipeline<ThisFieldType, ThisFieldType>)

    /// @name Queryable
    /// This field can be queried by the client
    declare unique model field decorator queryable

    /// @name Unqueryable
    /// This field can't be queried by the client
    declare unique model field decorator unqueryable

    /// @name Sortable
    /// This field can be sorted by the client
    declare unique model field decorator sortable

    /// @name Unsortable
    /// This field can't be sorted by the client
    declare unique model field decorator unsortable

    /// @name Can Read
    /// Specify the permission checker for read on this field
    declare unique model field decorator canRead(pipeline?: Pipeline<Self, Ignored>)

    /// @name Can Mutate
    /// Specify the permission checker for write on this field
    declare unique model field decorator canMutate(pipeline?: Pipeline<Self, Ignored>)

    /// @name Migration
    /// Specify the migration operation for this field
    declare unique model field decorator migration(
        renamed: Enumerable<String>?, 
        version: String?, 
        default: ThisFieldType?,
        priority: Int?
    )

    /// @name Dropped
    /// Specify that this field is dropped
    declare unique model field decorator dropped

    /// @name Relation
    /// Define a model relation
    declare unique model relation decorator relation {
        /// Define a normal relation
        variant(fields: Enumerable<SerializableScalarFields<Self>>, references: Enumerable<SerializableScalarFields<ThisFieldType>>, onUpdate: Update?, onDelete: Delete?)
        /// Define a through relation
        variant<T>(through: T, local: DirectRelations<T>, foreign: DirectRelations<T>, onUpdate: Update?, onDelete: Delete?) where T: Model
    }

    /// @name Getter
    /// Define a property with getter
    declare unique model property decorator getter(pipeline?: Pipeline<Self, ThisFieldType>)

    /// @name Setter
    /// Define a property with setter
    declare unique model property decorator setter(pipeline?: Pipeline<ThisFieldType, Ignored>)

    /// @name Cache
    /// Define a cached property, a cached property is saved into the database
    declare unique model property decorator cached

    /// @name Dependencies
    /// Define dependencies for a cached property
    declare unique model property decorator deps(deps?: Enumerable<SerializableScalarFields<Self>>)

    /// @name Index
    /// Define index for this cached property
    declare unique model property decorator index(sort: Sort?, length: Int?, map: String?)

    /// @name Unique
    /// Define unique index for this cached property
    declare unique model property decorator unique(sort: Sort?, length: Int?, map: String?)

    /// @name Input Omissible
    /// When type checking and generating clients, the input is always optional
    declare unique model property decorator inputOmissible

    /// @name Output Omissible
    /// When generating clients, the output is always optional
    declare unique model property decorator outputOmissible

    #end

    /// @name Generate Client
    /// Specify whether generate client for this model
    declare unique interface decorator generateClient(generate?: Bool)

    /// @name Generate Entity
    /// Specify whether generate entity for this model
    declare unique interface decorator generateEntity(generate?: Bool)

    /// @name Map
    /// Specify HTTP method and request path for this handler
    declare unique handler decorator map(method?: Method?, path?: String?, ignorePrefix: Bool?, interface: String?)

    #if available(database)

    /// @name Add
    /// Add a new numeric value
    declare pipeline item add<T>(value?: T | Pipeline<T, T>): T -> T where T: Int | Int64 | Float32 | Float | Decimal

    /// @name Sub
    /// Subtract a numeric value
    declare pipeline item sub<T>(value?: T | Pipeline<T, T>): T -> T where T: Int | Int64 | Float32 | Float | Decimal

    /// @name Mul
    /// Multiply a numeric value
    declare pipeline item mul<T>(value?: T | Pipeline<T, T>): T -> T where T: Int | Int64 | Float32 | Float | Decimal

    /// @name Div
    /// Divide a numeric value
    declare pipeline item div<T>(value?: T | Pipeline<T, T>): T -> T where T: Int | Int64 | Float32 | Float | Decimal

    /// @name Mod
    /// Mod a numeric value
    declare pipeline item mod<T>(value?: T | Pipeline<T, T>): T -> T where T: Int | Int64

    /// @name Floor
    /// Get the floor value
    declare pipeline item floor<T>: T -> T where T: Float32 | Float | Decimal

    /// @name Ceil
    /// Get the ceil value
    declare pipeline item ceil<T>: T -> T where T: Float32 | Float | Decimal

    /// @name Round
    /// Get the rounded value
    declare pipeline item round<T>: T -> T where T: Float32 | Float | Decimal

    /// @name Square Root
    /// Get the square root value
    declare pipeline item sqrt<T>: T -> T where T: Int | Int64 | Float32 | Float | Decimal

    /// @name Cube Root
    /// Get the cube root value
    declare pipeline item cbrt<T>: T -> T where T: Int | Int64 | Float32 | Float | Decimal

    /// @name Absolute Value
    /// Get the absolute value
    declare pipeline item abs<T>: T -> T where T: Int | Int64 | Float32 | Float | Decimal

    /// @name Power
    /// Get the power value
    declare pipeline item pow<T>(value?: T | Pipeline<T, Int>): T -> T where T: Int | Int64 | Float32 | Float

    /// @name Root
    /// Get the root value
    declare pipeline item root<T>(value?: T | Pipeline<T, Int>): T -> T where T: Int | Int64

    /// @name Min
    /// If current value is less than `value`, set the value to `value`
    declare pipeline item min<T>(value?: T | Pipeline<T, T>): T -> T where T: Int | Int64 | Float32 | Float | Decimal

    /// @name Max
    /// If current value is greater than `value`, set the value to `value`
    declare pipeline item max<T>(value?: T | Pipeline<T, T>): T -> T where T: Int | Int64 | Float32 | Float | Decimal

    /// @name Is Even
    /// throws if current value is not even
    declare pipeline item isEven<T>: T -> T where T: Int | Int64

    /// @name Is Odd
    /// throws if current value is not odd
    declare pipeline item isOdd<T>: T -> T where T: Int | Int64

    /// @name randomInt
    /// generate a random integer
    declare pipeline item randomInt {
        variant(range?: Range<Int>): Ignored -> Int
        variant(length?: Int): Ignored -> Int
    }

    /// @name randomFloat
    /// generate a random float
    declare pipeline item randomFloat(range?: Range<Float>): Ignored -> Float

    /// @name CUID
    /// generate a CUID
    declare pipeline item cuid: Ignored -> String

    /// @name CUID2
    /// generate a CUID2
    declare pipeline item cuid2: Ignored -> String

    /// @name UUID
    /// generate a UUID
    declare pipeline item uuid: Ignored -> String

    /// @name slug
    /// generate a slug
    declare pipeline item slug: Ignored -> String

    /// @name Random Digits
    /// generate a random digits string
    declare pipeline item randomDigits(len?: Int): Ignored -> String

    /// @name Ellipsis
    /// truncate string with ellipsis
    declare pipeline item ellipsis(ellipsis?: String, width?: Int | Pipeline<String, Int>): String -> String

    declare pipeline item padEnd(width?: Int | Pipeline<String, Int>, char?: String): String -> String

    declare pipeline item padStart(width?: Int | Pipeline<String, Int>, char?: String): String -> String

    declare pipeline item regexReplace(format?: Regex, substitute?: String): String -> String

    declare pipeline item split(separator?: String | Pipeline<String, String>): String -> String[]

    declare pipeline item trim: String -> String

    declare pipeline item toWordCase: String -> String

    declare pipeline item toLowerCase: String -> String

    declare pipeline item toUpperCase: String -> String

    declare pipeline item toSentenceCase: String -> String

    declare pipeline item toTitleCase: String -> String

    declare pipeline item hasPrefix(prefix?: String | Pipeline<String, String>): String -> String

    declare pipeline item hasSuffix(suffix?: String | Pipeline<String, String>): String -> String

    declare pipeline item isPrefixOf(value?: String | Pipeline<String, String>): String -> String

    declare pipeline item isSuffixOf(value?: String | Pipeline<String, String>): String -> String

    declare pipeline item isAlphabetic: String -> String

    declare pipeline item isAlphanumeric: String -> String

    declare pipeline item isEmail: String -> String

    declare pipeline item isHexColor: String -> String

    declare pipeline item isNumeric: String -> String

    declare pipeline item isSecurePassword: String -> String

    declare pipeline item regexMatch(regex?: Regex): String -> String

    /// @name Print
    /// Print the current pipeline ctx value for debug purpose.
    declare pipeline item print<T>(label?: String?): T -> T

    /// @name Message
    /// If error occurred, replace error message and error code if specified
    declare pipeline item message<T, U>(pipeline?: Pipeline<T, U>, message?: String, code?: Int?): T -> U

    declare pipeline item presents<T>: T? -> T

    declare pipeline item when<T, U>(action?: Action, pipeline?: Pipeline<T, U>, otherwise: Pipeline<T, U>?): T -> U

    declare pipeline item append {
        variant(value?: String | Pipeline<String, String>): String -> String
        variant<T>(value?: T | Pipeline<T[], T>): T[] -> T[]
    }

    declare pipeline item prepend {
        variant(value?: String | Pipeline<String, String>): String -> String
        variant<T>(value?: T | Pipeline<T[], T>): T[] -> T[]
    }

    declare pipeline item getLength {
        variant: String -> Int
        variant<T>: T[] -> Int
    }

    declare pipeline item hasLength {
        variant(len?: Int): String -> String
        variant(range?: Range<Int>): String -> String
        variant<T>(len?: Int): T[] -> T[]
        variant<T>(range?: Range<Int>): T[] -> T[]
    }

    declare pipeline item reverse {
        variant: String -> String
        variant<T>: T[] -> T[]
    }

    declare pipeline item truncate {
        variant(maxLen?: Int | Pipeline<String, Int>): String -> String
        variant<T>(maxLen?: Int | Pipeline<T[], Int>): T[] -> T[]
    }

    declare pipeline item now: Ignored -> DateTime

    declare pipeline item today<T>(tz?: Int | Pipeline<T, Int>): T -> Date

    declare pipeline item toDate(tz?: Int | Pipeline<DateTime, Int>): DateTime -> Date

    /// @name Valid
    /// This pipeline item is always valid
    declare pipeline item valid<T>: T -> T

    declare pipeline item invalid<T>: T -> T

    /// @name Passed
    /// When `pipeline` doesn't throw, returns true
    declare pipeline item passed<T>(pipeline?: Pipeline<T, Ignored>): T -> Bool

    declare pipeline item if<T, U, V>(cond?: Pipeline<T, U>, then?: Pipeline<U, V>?, else: Pipeline<T, V>?): T -> V

    declare pipeline item validate<T>(pipeline?: Pipeline<T, Ignored>): T -> T

    declare pipeline item all<T>(pipelines?: Pipeline<T, Ignored>[]): T -> T

    declare pipeline item any<T>(pipelines?: Pipeline<T, Ignored>[]): T -> T

    declare pipeline item do<T>(pipeline?: Pipeline<T, Ignored>): T -> T

    declare pipeline item not<T>(pipeline?: Pipeline<T, Ignored>): T -> T

    /// @name Cast
    /// Cast the output value to the type described in the argument
    declare pipeline item cast<T, K>(target?: K): Any -> T where T: TypeValueAsType<K>, K: Type

    /// @name Match
    /// Match the value against the arms and return the result
    declare pipeline item match<T, U, V>(value?: Pipeline<T, U>, arms?: Pipeline<U, V>[]): T -> V

    /// @name Case
    /// `$case` is designed to be used together with `$match`
    declare pipeline item case<T, U, V>(arm?: Pipeline<T, U>, exec?: Pipeline<U, V>): T -> V

    /// @name As Any
    /// Cast the value to Any type
    declare pipeline item asAny: Ignored -> Any

    /// @name Is
    /// True if input is value. For model objects, it performs a natural match. Otherwise, a `==` is used
    declare pipeline item is<T>(value?: T | Pipeline<T, T>): T -> T

    /// @name Self
    /// Get the current pipeline context object
    declare pipeline item self: Ignored -> Self

    /// @name Set
    /// Set the value on object or map
    declare pipeline item set {
        variant<T, K>(key?: K, value?: T[K]): T -> T where K: ScalarFields<T>, T: Model
        variant<T, K>(key?: K, value?: T[K]): T -> T where K: ShapeField<T>, T: Shape
        variant<T>(key?: String, value?: T): T{} -> T{}
        variant<T>(key?: Int): T[] -> T[]
    }

    /// @name Get
    /// Get the value on model object, array or dictionary
    declare pipeline item get {
        variant<T, K>(key?: K): T -> T[K]? where K: ScalarFields<T>, T: Model
        variant<T, K>(key?: K): T -> T[K]? where K: ShapeField<T>, T: Shape
        variant<T>(key?: String): T{} -> T?
        variant<T>(key?: Int): T[] -> T?
    }

    /// @name Previous
    /// Get the previous object value
    declare pipeline item previous<T, K>(key?: K): T -> T[K]? where K: ScalarFields<T>, T: Model

    /// @name Assign
    /// Assign value to key on context object
    declare pipeline item assign<T, K>(key?: K, value?: Self[K] | Pipeline<T, Self[K]>): T -> T where K: ScalarFields<Self>

    /// @name Equal
    /// Valid if input is equal to rhs
    declare pipeline item eq<T>(rhs?: T | Pipeline<T, T>): T -> T

    /// @name Greater Than
    /// Valid if input is greater than rhs
    declare pipeline item gt<T>(rhs?: T | Pipeline<T, T>): T -> T

    /// @name Greater Than Or Equal
    /// Valid if input is greater than or equal to rhs
    declare pipeline item gte<T>(rhs?: T | Pipeline<T, T>): T -> T

    /// @name less Than
    /// Valid if input is less than rhs
    declare pipeline item lt<T>(rhs?: T | Pipeline<T, T>): T -> T

    /// @name less Than Or Equal
    /// Valid if input is less than or equal to rhs
    declare pipeline item lte<T>(rhs?: T | Pipeline<T, T>): T -> T

    /// @name Not Equal
    /// Valid if input is not equal to rhs
    declare pipeline item neq<T>(rhs?: T | Pipeline<T, T>): T -> T

    /// @name Is False
    /// Valid if input is false
    declare pipeline item isFalse: Bool -> Bool

    /// @name Is True
    /// Valid if input is true
    declare pipeline item isTrue: Bool -> Bool

    /// @name Is Null
    /// Valid if input is null
    declare pipeline item isNull<T>: T? -> T?

    /// @name One Of
    /// Valid if input is one of candidates
    declare pipeline item oneOf<T>(candidates?: T[] | Pipeline<T, T[]>): T -> T

    /// @name Join
    /// Join string array into a string with separator
    declare pipeline item join(separator?: String | Pipeline<String[], String>): String[] -> String

    /// @name Filter
    /// Filter items by pipeline
    declare pipeline item filter<T>(pipeline?: Pipeline<T, Ignored>): T[] -> T[]

    /// @name Map
    /// Perform map and collect results on array
    declare pipeline item map<T, U>(pipeline?: Pipeline<T, U>): T[] -> U[]

    /// @name Identity
    /// Fetch identity from the request.
    declare pipeline item account(): Ignored -> Any

    #end

    /// @name Empty
    /// The empty interface
    interface Empty { }

    /// @name Data
    /// This interface is common for action output
    interface Data<T> {
        data: T
    }

    /// @name Data and Meta
    /// This interface is common for action output with meta information
    interface DataMeta<T, U> {
        data: T
        meta: U
    }

    interface PagingInfo {
        count: Int64
        numberOfPages: Int64?
    }

    interface ResponseError {
        type: String
        message: String
        fields: String{} | Null
    }

    #if available(database)

    interface BoolFilter {
        equals: Bool?
        not: (Bool | BoolFilter)?
    }

    interface BoolNullableFilter {
        equals: (Bool | Null)?
        not: (Bool | Null | BoolNullableFilter)?
    }

    interface Filter<T> {
        equals: T?
        in: T[]?
        notIn: T[]?
        lt: T?
        lte: T?
        gt: T?
        gte: T?
        not: (T | Filter<T>)?
    }

    interface NullableFilter<T> {
        equals: (T | Null)?
        in: (T | Null)[]?
        notIn: (T | Null)[]?
        lt: T?
        lte: T?
        gt: T?
        gte: T?
        not: (T | Null | NullableFilter<T>)?
    }

    interface StringFilter {
        equals: String?
        in: String[]?
        notIn: String[]?
        lt: String?
        lte: String?
        gt: String?
        gte: String?
        contains: String?
        startsWith: String?
        endsWith: String?
        matches: String?
        mode: StringMatchMode?
        not: (String | StringFilter)?
    }

    interface StringNullableFilter {
        equals: (String | Null)?
        in: (String | Null)[]?
        notIn: (String | Null)[]?
        lt: String?
        lte: String?
        gt: String?
        gte: String?
        contains: String?
        startsWith: String?
        endsWith: String?
        matches: String?
        mode: StringMatchMode?
        not: (String | Null | StringNullableFilter)?
    }

    interface EnumFilter<T> {
        equals: T?
        in: T[]?
        notIn: T[]?
        not: (T | EnumFilter<T>)?
    }

    interface EnumNullableFilter<T> {
        equals: (T | Null)?
        in: (T | Null)[]?
        notIn: (T | Null)[]?
        not: (T | Null | EnumNullableFilter<T>)?
    }

    interface ArrayFilter<T> {
        equals: T[]?
        has: T?
        hasSome: T[]?
        hasEvery: T[]?
        isEmpty: Bool?
        length: Int?
    }

    interface ArrayNullableFilter<T> {
        equals: (T[] | Null)?
        has: T?
        hasSome: T[]?
        hasEvery: T[]?
        isEmpty: Bool?
        length: Int?
    }

    interface BoolWithAggregatesFilter extends BoolFilter {
        _count: Int64?
        _min: BoolFilter?
        _max: BoolFilter?
    }

    interface BoolNullableWithAggregatesFilter extends BoolNullableFilter {
        _count: Int64?
        _min: BoolNullableFilter?
        _max: BoolNullableFilter?
    }

    interface IntNumberWithAggregatesFilter<T> extends Filter<T> {
        _count: Int64?
        _min: Filter<T>?
        _max: Filter<T>?
        _avg: Filter<Float>?
        _sum: Filter<Int64>?
    }

    interface IntNumberNullableWithAggregatesFilter<T> extends NullableFilter<T> {
        _count: Int64?
        _min: NullableFilter<T>?
        _max: NullableFilter<T>?
        _avg: NullableFilter<Float>?
        _sum: NullableFilter<Int64>?
    }

    interface FloatNumberWithAggregatesFilter<T> extends Filter<T> {
        _count: Int64?
        _min: Filter<T>?
        _max: Filter<T>?
        _avg: Filter<Float>?
        _sum: Filter<Float>?
    }

    interface FloatNumberNullableWithAggregatesFilter<T> extends NullableFilter<T> {
        _count: Int64?
        _min: NullableFilter<T>?
        _max: NullableFilter<T>?
        _avg: NullableFilter<Float>?
        _sum: NullableFilter<Float>?
    }

    interface DecimalWithAggregatesFilter extends Filter<Decimal> {
        _count: Int64?
        _min: Filter<Decimal>?
        _max: Filter<Decimal>?
        _avg: Filter<Decimal>?
        _sum: Filter<Decimal>?
    }

    interface DecimalNullableWithAggregatesFilter<T> extends NullableFilter<T> {
        _count: Int64?
        _min: NullableFilter<Decimal>?
        _max: NullableFilter<Decimal>?
        _avg: NullableFilter<Decimal>?
        _sum: NullableFilter<Decimal>?
    }

    interface AggregatesFilter<T> extends Filter<T> {
        _count: Int64?
        _min: Filter<T>?
        _max: Filter<T>?
    }

    interface NullableAggregatesFilter<T> extends NullableFilter<T> {
        _count: Int64?
        _min: NullableFilter<T>?
        _max: NullableFilter<T>?
    }

    interface StringWithAggregatesFilter extends StringFilter {
        _count: Int64?
        _min: StringFilter?
        _max: StringFilter?
    }

    interface StringNullableWithAggregatesFilter extends StringNullableFilter {
        _count: Int64?
        _min: StringNullableFilter?
        _max: StringNullableFilter?
    }

    interface EnumWithAggregatesFilter<T> extends EnumFilter<T> {
        _count: Int64?
        _min: EnumFilter<T>?
        _max: EnumFilter<T>?
    }

    interface EnumNullableWithAggregatesFilter<T> extends EnumNullableFilter<T> {
        _count: Int64?
        _min: EnumNullableFilter<T>?
        _max: EnumNullableFilter<T>?
    }

    interface ArrayWithAggregatesFilter<T> extends ArrayFilter<T> {
        _count: Int64?
        _min: ArrayFilter<T>?
        _max: ArrayFilter<T>?
    }

    interface ArrayNullableWithAggregatesFilter<T> extends ArrayNullableFilter<T> {
        _count: Int64?
        _min: ArrayNullableFilter<T>?
        _max: ArrayNullableFilter<T>?
    }

    interface NumberAtomicUpdateOperationInput<T> {
        increment: T?
        decrement: T?
        multiply: T?
        divide: T?
    }

    interface ArrayAtomicUpdateOperationInput<T> {
        push: T?
    }

    @generateClient(false) @generateEntity(false) @showInStudio(false) @synthesizeShapes(false)
    model DataSetRecord {

        @id @default($cuid)
        id: String

        dataSet: String

        group: String

        name: String

        record: String
    }

    @generateClient(false) @generateEntity(false) @showInStudio(false) @synthesizeShapes(false)
    model DataSetRelation {

        @id @default($cuid)
        id: String

        dataSet: String

        groupA: String

        relationA: String

        nameA: String

        groupB: String

        relationB: String?

        nameB: String
    }

    #end

    /// @name Bcrypt
    /// Bcrypt related pipeline items
    namespace bcrypt {

        /// @name Salt
        /// Transform this string value with Bcrypt salt
        declare pipeline item salt: String -> String

        /// @name Verify
        /// Verify with Bcrypt verify
        declare pipeline item verify(pipeline?: Pipeline<String, String>): String -> String
    }

    /// @name Identity
    /// Identity and user session
    namespace identity {

        interface TokenInfo {
            token: String
        }

        declare synthesized shape SignInCheckerIds {
            declare optional synthesized field with @identity.id
        }

        declare synthesized shape SignInCheckerCompanions {
            declare optional synthesized field with @identity.companion
        }

        @generateClient(false) @generateEntity(false)
        interface SignInCheckerArgs<T, C, I> {
            value: T
            companions: C
            ids: I
        }

        declare synthesized shape SignInInput {
            credentials: SignInArgs<Self>
            select: Select<Self>?
            include: Include<Self>?
        }

        declare synthesized shape SignInArgs {
            declare optional synthesized field with @identity.id
            declare optional synthesized field with @identity.checker
            declare optional synthesized field with @identity.companion
        }

        declare unique model decorator tokenIssuer(pipeline?: Pipeline<SignInArgs<Self>, String>)

        declare unique model decorator validateAccount(pipeline?: Pipeline<Self, Ignored>)

        declare unique model decorator jwtSecret(secret?: String)

        declare model field decorator id

        declare model field decorator checker(pipeline?: Pipeline<SignInCheckerArgs<ThisFieldType, SignInCheckerCompanions<Self>, SignInCheckerIds<Self>>, Ignored>)

        declare model field decorator companion

        declare pipeline item jwt(expired: (Int64 | Pipeline<SignInArgs<Self>, Int64>)?): SignInArgs<Self> -> String

        declare handler template signIn(SignInInput<Self>): DataMeta<Result<Self>, TokenInfo>

        declare handler template identity(Args<Self>): Data<Result<Self>>

        declare middleware identityFromJwt(secret?: String)
    }

    /// @name Admin
    /// The admin dashboard functionalities
    namespace admin {

        /// @name Language
        /// The human language that is supported
        interface enum Language {
            enUs
            enUk
            de
            fr
            es
            hi
            he
            ja
            ko
            zhCn
            zhTw
        }

        /// @name Administrator
        /// Use this model as a administrator in admin dashboard
        declare model decorator administrator

        /// @name Title
        /// Use this field as a record's title in admin dashboard
        declare model field decorator title

        /// @name Subtitle
        /// Use this field as a record's subtitle in admin dashboard
        declare model field decorator subtitle

        /// @name Cover Image
        /// Use this field as a record's cover image in admin dashboard
        declare model field decorator coverImage

        /// @name Embedded
        /// The related object or objects display in this model's form
        declare model relation decorator embedded
    }
}
